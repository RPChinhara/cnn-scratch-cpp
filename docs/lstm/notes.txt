-------------------- Why use vslice() in BPTT? --------------------

Slice weights to (50, 50) from (50, 51) for using only columns multiplied to h. See example below.
Only 1s and 2s will be multiplied to values that are h. All 3s are multpiled to x, and I only care about
weights that are contributing to h because whem I'm trying to get gradients respect to h like below do_10/dw_o, dc_tilde_10/dw_c,
all I care is how much weights are related from this concatenation w * [h + x].
1 2 3          3 3 3 3 2 2 2 2 2 2 this is h
1 2 3          3 3 3 3 2 2 2 2 2 2 this is h
1 2 3          3 3 3 3 2 2 2 2 2 2 this is x

-------------------- LSTM BPTT --------------------

tensor concat1 = vstack({h_0, transpose(x_1)});

tensor z_f_1 = matmul(w_f, concat1) + b_f;
tensor f_1 = sigmoid(z_f_1);

tensor z_i_1 = matmul(w_i, concat1) + b_i;
tensor i_1 = sigmoid(z_i_1);

tensor z_c_tilde_1 = matmul(w_c, concat1) + b_c;
tensor c_tilde_1 = hyperbolic_tangent(z_c_tilde_1);

c_1 = f_1 * c_0 + i_1 * c_tilde_1;

tensor z_o_1 = matmul(w_o, concat1) + b_o;
tensor o_1 = sigmoid(z_o_1);

h_1 = o_1 * hyperbolic_tangent(c_1);
tensor y_1 = matmul(w_y, h_1) + b_y;

tensor concat2 = vstack({h_1, transpose(x_2)});

tensor z_f_2 = matmul(w_f, concat2) + b_f;
tensor f_2 = sigmoid(z_f_2);

tensor z_i_2 = matmul(w_i, concat2) + b_i;
tensor i_2 = sigmoid(z_i_2);

tensor z_c_tilde_2 = matmul(w_c, concat2) + b_c;
tensor c_tilde_2 = hyperbolic_tangent(z_c_tilde_2);

c_2 = f_2 * c_1 + i_2 * c_tilde_2;

tensor z_o_2 = matmul(w_o, concat2) + b_o;
tensor o_2 = sigmoid(z_o_2);

h_2 = o_2 * hyperbolic_tangent(c_2);
tensor y_2 = matmul(w_y, h_2) + b_y;

| Considering only w_o |

tensor concat_1 = vstack({h_0, transpose(x_1)});

tensor z_o_1 = matmul(w_o, concat_1) + b_o;
tensor o_1 = sigmoid(z_o_1);

h_1 = o_1 * hyperbolic_tangent(c_t);

tensor concat_2 = vstack({h_1, transpose(x_2)});

tensor z_o_2 = matmul(w_o, concat_2) + b_o;
tensor o_2 = sigmoid(z_o_2);

h_2 = o_2 * hyperbolic_tangent(c_t);

tensor concat_3 = vstack({h_2, transpose(x_3)});

tensor z_o_3 = matmul(w_o, concat_3) + b_o;
tensor o_3 = sigmoid(z_o_3);

h_3 = o_3 * hyperbolic_tangent(c_t);

tensor y_t = matmul(w_y, h_3) + b_y;

| Considering only w_c |

tensor concat_1 = vstack({h_0, transpose(x_1)});

tensor z_c_tilde_1 = matmul(w_c, concat_1) + b_c;
tensor c_tilde_1 = hyperbolic_tangent(z_c_tilde_1);

c_1 = f_1 * c_0 + i_1 * c_tilde_1;

tensor z_o_1 = matmul(w_o, concat) + b_o;
tensor o_1 = sigmoid(z_o_1);

h_1 = o_1 * hyperbolic_tangent(c_1);

tensor y_1 = matmul(w_y, h_1) + b_y;

tensor concat_2 = vstack({h_1, transpose(x_2)});

tensor z_c_tilde_2 = matmul(w_c, concat_2) + b_c;
tensor c_tilde_2 = hyperbolic_tangent(z_c_tilde_2);

c_2 = f_2 * c_1 + i_2 * c_tilde_2;

tensor z_o_2 = matmul(w_o, concat) + b_o;
tensor o_2 = sigmoid(z_o_2);

h_2 = o_2 * hyperbolic_tangent(c_2);

tensor y_2 = matmul(w_y, h_2) + b_y;

-------------------- LSTM BPTT2 --------------------

tensor concat = vstack({h_t, transpose(x_t)});

tensor z_f = matmul(w_f, concat) + b_f;
tensor f_t = sigmoid(z_f);

tensor z_i = matmul(w_i, concat) + b_i;
tensor i_t = sigmoid(z_i);

tensor z_c_tilde_t = matmul(w_c, concat) + b_c;
tensor c_tilde_t = hyperbolic_tangent(z_c_tilde_t);

c_t = f_t * c_t + i_t * c_tilde_t;

tensor z_o = matmul(w_o, concat) + b_o;
tensor o_t = sigmoid(z_o);

h_t = o_t * hyperbolic_tangent(c_t);

tensor y_t = matmul(w_y, h_t) + b_y;

=====================================================================================================================================
Check forward pass on https://en.wikipedia.org/wiki/Long_short-term_memory to remind myself that way to compute gradients make sense.
(dL/dy * dy/dh_10) * dh_10/do_10 * do_t10/dw_o
(dL/dy * dy/dh_10 * dh_10/do_10 * do_10/dh_9) * dh_9/do_9 * do_9/dw_o
(dL/dy * dy/dh_10 * dh_10/do_10 * do_10/dh_9 * dh_9/do_9 * do_9/dh_8) * dh_8/do_8 * do_8/dw_o
=====================================================================================================================================
(dL/dy * dy/dh_10) * dh_10/dc_10 * dc_10/dc_tilde_10 * dc_tilde_10/dw_c
(dL/dy * dy/dh_10 * dh_10/dc_10 * dc_10/dc_tilde_10 * dc_tilde_10/dh_9) * dh_9/dc_9 * dc_9/dc_tilde_9 * dc_tilde9/dw_c

dh10/do10 * do10/wo
dh10/do10 * do10/dh9 * dh9/do9 * do9/wo

dh10/dc10 * dc10/d~c10 * d~c10/w_c
dh10/dc10 * dc10/d~c10 * d~c10/dh9 * dh9/dc9 * dc9/d~c9 * d~c9/wc
=====================================================================================================================================
(dL/dy * dy/dh_10) * dh_10/dc_10 * dc_10/di_10 * di_10/dw_i
(dL/dy * dy/dh_10 * dh_10/dc_10 * dc_10/di_10 * di_10/dh_9) * dh_9/dc_9 * dc_9/di_9 * di_9/dw_i
=====================================================================================================================================
(dL/dy * dy/dh_10) * dh_10/dc_10 * dc_10/df_10 * df_10/dw_f
(dL/dy * dy/dh_10 * dh_10/dc_10 * dc_10/df_10 * df_10/dh_9) * dh_9/dc_9 * dc_9/df_9 * df_9/dw_f
=====================================================================================================================================